<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[hnnWang's Blog]]></title>
  <link href="http://hoowater.github.io/atom.xml" rel="self"/>
  <link href="http://hoowater.github.io/"/>
  <updated>2015-02-11T20:31:56+08:00</updated>
  <id>http://hoowater.github.io/</id>
  <author>
    <name><![CDATA[hnnWang]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[2014北邮新生训练五div2题解]]></title>
    <link href="http://hoowater.github.io/blog/2014/12/26/2014bei-you-xin-sheng-xun-lian-wu-div2ti-jie/"/>
    <updated>2014-12-26T19:40:01+08:00</updated>
    <id>http://hoowater.github.io/blog/2014/12/26/2014bei-you-xin-sheng-xun-lian-wu-div2ti-jie</id>
    <content type="html"><![CDATA[<p>上周刚出完一场div1，这周有找了场div2，希望大家做得愉快吧！都是一些比较水的题目。</p>

<!-- more -->


<p>A.滑雪</p>

<p><a href="http://poj.org/problem?id=1088">POJ1088</a></p>

<p>记忆化搜索的入门题目，OI的题目，算是比较经典了吧，挂出来主要是为了让大家练习一下记忆化搜索，毕竟周三刚讲的！大家估计好多人都做过了吧！</p>

<p>记忆化搜索，设置一个记忆化数组（我用的dp[R][C] ），dp[ i ][ j ]来记录搜索到从某个最高点到坐标为i,j的点的最长路径。那么dp[ i ][ j ]初始化应该为1，因为最短也是可以划1的长度的。然后对所有是路径长度是1的位置（即dp[ i ][ j ] == 1的位置）进行记忆化搜索，搜索过程中更新所有可以到达的位置的dp[ i ][ j ]的值。</p>

<p>我的另外一种做法是，先把所有点的坐标和高度捆绑记录起来，然后根据高度对这些点进行排序，之后按照从高到低（从低到高也一样）的顺序，依次对dp[ i ][ j ]的值进行更新。</p>

<p>两种方案的<a href="http://hoowater.github.io/acm/poj/poj1088/">参考代码</a>都在这里。</p>

<p>B.Best Cow Line</p>

<p><a href="http://poj.org/problem?id=3617">POJ3617</a></p>

<p>水题，题意很简单，给你个一个长度为n的字符串S的各个位上的字符（就当成是给你个字符串吧，其实也就是考验了下读入），让你每次从S的首或者尾取一位放到初始为空的一个字符串中，构造一个新的字符串T，让T的字典序最小。</p>

<p>思路也比较简单，就是一个很简单的贪心，反转原字符串得到一个字符串S’，然后比较S和S‘哪个的字典序小，就从哪个的串首取出来放到T中（从S’的串首取出来就相当于从S的串尾取出来），然后更新对应的字符串（灵活一点，用&amp;s[i]表示从第i+1位开始的字符串），当T的长度到达n的时候就构造完毕了。</p>

<p>这里放上我的<a href="http://hoowater.github.io/acm/poj/poj3617/">参考代码</a></p>

<p>C.Little Pony and Alohomora Part I</p>

<p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=4986">HDU4986</a></p>

<p>看表情也知道这道题是这里面比较难的题目了，放在div2里，算是为了防AK吧，目的是传递一种思想！</p>

<p>题意，给你n各箱子，箱子里随机放着n把钥匙（钥匙分别对n个箱子），你打开箱子有2种方法，一种是用对应的钥匙打开箱子，第二种就是暴力打开箱子，问你打开所有箱子需要的暴力次数的期望值。</p>

<p>我们考虑到，当只有一个箱子的时候，必然需要且仅需要一次暴力，想一想可不可以通过这个来递推呢？应该是可以的，怎么来递推呢？想一下在n个箱子的基础上，加一个箱子（n+1号箱子），可能出现哪些情况？一是这个箱子（n+1）里放的钥匙就是与他本身对应的钥匙（n+1），这种情况下的次数应该是原来的次数+1，因为这个箱子必然要暴力打开；二是这个箱子放的是前面的某个箱子的钥匙，这种情况下的暴力次数应该跟原来是一样的，我们如果之前能够打开前面的所有箱子，那么我们就肯定能够打开放着最后一个箱子钥匙的那个箱子（想一想，为什么？），也就肯定能够拿出里面的钥匙。那么，通过以上的分析，我们如果用f[n]来表示n个箱子需要暴力的次数的期望，那么我们有如下的递推关系:</p>

<p>f[n+1] = f[n] * n/(n+1) + (f[n]+1)/(n+1) = f[n] + 1/(n+1);</p>

<p>f[1] = 1;</p>

<p>那么我们得到一个直接计算n个箱子的答案的式子：1 + &frac12; + 1/3 + &frac14; + ………… + 1/n;也就是调和级数的和，但是，当我们兴致冲冲地以为自己已经做出来的时候，看到1000000000范围的n，瞬间就有一种吐血的冲动！这太大了，没法求呀，直接求和肯定会T的呀！数学帝会告诉你，这是有公式的，当n足够大的时候，调和级数的和约等于<strong>ln(n+1) + r(r为欧拉常熟）</strong>不要问我怎么推的，去问那些数学帝，我不会！我出这个题目呢，自然也是有目的的，不过不是这个公式，而是另外一种方法，一种很暴力的方法！我们称之为乱搞法，（真的是乱搞），或者说，桶分打表大法！具体方法如下：</p>

<p>首先，我们考虑到答案的范围，n是1000000000，需要分一下桶（先不要问什么是桶，接着看就好），大小呢，看情况而定，我选的是1000000的桶（就是每隔100万个数记录一个值保存下来）；</p>

<p>然后呢，利用暴力打表的方法（不用考虑时间，这个会吧？），把n=0, n=100万， n=200万 …… n=10亿 的值打印在一个文本文档中（记得打印逗号，每2个数中间要有一个逗号）；</p>

<p>再然后，把表中的所有数，复制，然后初始化一个1000多的数组（因为我的桶选的是100万，所以只需要1000个），把打印的那些数存起来，这就叫存在了桶中；</p>

<p>最后，根据他所给的数，看他给的数属于哪个桶，然后暴力计算即可！！</p>

<p>以上的介绍应该还是比较详细吧，大家可以试一试，万一碰到一道题可以这么搞一搞呢？这叫我不会做，但是我能把它A掉。</p>

<p>同样两种方法的<a href="http://hoowater.github.io/acm/hdu/hdu4986/">参考代码</a>都贴出来了！</p>

<p>D.Hard Code</p>

<p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=4813">HDU4813</a></p>

<p>这题一道模拟水题，不写了，十分简单。</p>

<p>E.Crazy Town</p>

<p><a href="http://codeforces.com/problemset/problem/498/A">CF498A</a></p>

<p>这是12月24日那天的codefroce div2的C题，不过不是很难，题意如下：</p>

<p>一些直线把一个平面分成了n块区域，给你家的坐标和学校的坐标，求从家到学校最少需要跨几条直线（不能从两直线交点处跨过）。想明白了就是很简单的一道题，其实就是家与学校之间总共有多少条直线，直接暴力判断就行了。至于怎么判断两个点在一条直线的同侧还是异侧，不会的请去翻中学数学课本的解析几何那章。需要注意一点,有可能会爆int的233333.</p>

<p><a href="http://hoowater.github.io/acm/CF/cf498a/">参考代码</a></p>

<p>F.Keyboard</p>

<p><a href="http://codeforces.com/problemset/problem/474/A">CF474A</a></p>

<p>跟E题一样，十分简单的一个模拟题，没有什么需要思考的东西，相信大家都能写出来，所以题解也就不写了！</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[配置Octopress过程中遇到的问题]]></title>
    <link href="http://hoowater.github.io/blog/2014/12/19/pei-zhi-octopressguo-cheng-zhong-yu-dao-de-wen-ti/"/>
    <updated>2014-12-19T19:47:54+08:00</updated>
    <id>http://hoowater.github.io/blog/2014/12/19/pei-zhi-octopressguo-cheng-zhong-yu-dao-de-wen-ti</id>
    <content type="html"><![CDATA[<p>我是在ubuntu14.04下配置的octopress，第一次和第二次配置遇到了同样的问题。</p>

<!--more-->


<p>首先，配置过程我是按照syx的这篇<a href="http://syncshinee.github.io/blog/2014/06/15/wo-de-octopressbo-ke/">博客</a>来的.</p>

<p>然后在<strong>rake generate</strong> 的时候出现了问题，仔细看了一下结果，是因为javascript没有安装，于是百度安装js，这个百度的大部分都是可以解决的。</p>

<p>接着在rake deploy的时候又出现了问题，推送不上去，报错如下</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'> ! [rejected]        master -&gt; master (non-fast-forward)
</span><span class='line'>error: failed to push some refs to 'https://github.com/yeesterbunny/yeesterbunny.github.com.git'
</span><span class='line'>hint: Updates were rejected because the tip of your current branch is behind
</span><span class='line'>hint: its remote counterpart. Merge the remote changes (e.g. 'git pull')
</span><span class='line'>hint: before pushing again.
</span><span class='line'>hint: See the 'Note about fast-forwards' in 'git push --help' for details.</span></code></pre></td></tr></table></div></figure>


<p>这个问题，我是找到这篇<a href="http://allenyee.me/blog/2013/08/21/what-i-learned-from-hosting-octopress-on-github/">博客</a>解决的.</p>

<p>如果有人遇到了跟我一样的问题，希望这些能够给你一些帮助！</p>

<p>之前的博客忘记了推送source，结果现在源文件找不到了，所以只能重开一个了2333333T_T!!</p>

<p><a href="http://hoowater.github.io/blog/archives">返回</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[2014北邮新生训练4div1题解]]></title>
    <link href="http://hoowater.github.io/blog/2014/12/19/2014bei-you-xin-sheng-xun-lian-4/"/>
    <updated>2014-12-19T18:43:37+08:00</updated>
    <id>http://hoowater.github.io/blog/2014/12/19/2014bei-you-xin-sheng-xun-lian-4</id>
    <content type="html"><![CDATA[<h1>Solution For BUPT winter training for 2014 round #4（div1）</h1>

<h2>计算几何专场</h2>

<!--more-->


<p>A.Beauty Contest</p>

<p><a href="http://poj.org/problem?id=2187">POJ2187</a></p>

<p>这题其实挺简单，就是给你n个点（n&lt;=50000），让你求这些点中距离最远的两个点的平方和。</p>

<p>其实这道题应该是一道旋转卡壳的题目，不过由于数据比较水，求出凸包之后暴力枚举凸包上的每一个点求平方和的最大值就行，套板子就可以。这道题应该是这些题目中除了附加题以外最难的题目了，不过会了凸包以后，敢于暴力水一发的话，就属于水题了。这道题的目的是让大家在感觉没有头绪的时候（对于这题来说，就是会凸包但是不会旋转卡壳的时候），尝试水一发，兴许就过了！！！B题也有这个目的，B题其实也是直接暴力水一发就好。至于不会凸包什么的，可以先不用着急，以后会讲的，这里就不做过多的叙述了，代码放在下面，仅供参考！</p>

<p><a href="http://hoowater.github.io/acm/poj/poj2187/">参考代码</a></p>

<p>B.Finding the Top RPS Player</p>

<p><a href="http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2119">AOJ2119</a></p>

<p>这是这次训练中题面最长的一道题目了，也是这场训练中唯一跟计算几何不沾边的题目，不过却是一道很简单的题目，是个模拟题大意如下：</p>

<p>n个人进行猜拳比赛，刚开始所有人得分都是0，每赢一场得1分，输了的话分数清零，每轮所有分数相同的人进行比赛（比如分数如下：2 2 2 1 1 1 0 0 0 0， 那么进行一轮比赛后应该变为 3 0 2 2 0 1 1 1 0 0，也就是3 2 2 1 1 1 0 0 0 0），问经过多少轮比赛后，最高分能够达到m分。</p>

<p>如果想多了，那么这题你就做不出来了，直接根据他说的规则模拟就好，因为数据很小，暴力写出来以后发现20 19 这样最复杂的数据 也是秒出。</p>

<p>参考代码不要着急看，自己先敲，实在搞定不了再去看！</p>

<p><a href="http://hoowater.github.io/acm/aoj/aizu2119/">参考代码</a></p>

<p>C.Collision</p>

<p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=4793">HDU4793</a></p>

<p>这道题，是13年长沙现场赛的C题，过的人不少，有兴趣的同学可以到<a href="http://board.acmicpc.info/icpc2013/hnu_onsite.php">这里</a>看一下榜，重点留意一下各个队伍过这一道题的时间。</p>

<p>实际上，这是一道十分简单的计算几何题目，在我看来，应该属于跟签到题一样难度的，先来说下题意：一个圆环，圆心在原点，给你内圆和外圆半径，在圆环<strong>外部</strong>有一个小圆，给你圆心坐标和半径以及速度矢量（也就是向量），运动过程中可以穿过外圆而不能穿过内圆，运动遵循牛顿物理定律，求小圆在圆环内部（小圆的任何一部分在内部都算）的总时间。如下图所示</p>

<p><img src="http://hoowater.github.io/picture/hdu4793/C1.png" alt="" /></p>

<p>那么，我们其实很容易就能想到怎么做了，小球运动总共有以下4种情况</p>

<p><img src="http://hoowater.github.io/picture/hdu4793/C2.png" alt="" /></p>

<p>第1种，运动方向是远离圆环的方向，这种情况下，小球不可能进入圆环的内部，所以时间为0.（至于判断，判断 速度向量v 和 小球圆心指向圆环圆心的向量v1 的点积符号即可，小于等于0的话，就永远不可能进入）</p>

<p>第2种，小球虽然是向靠近圆环的方向移动，但是距离最近的时候也没有进入圆环内部，这种情况下时间也肯定是0.</p>

<p>第3种，小球进入了圆环的外圆内部，却不与内圆相撞，这种情况下，算出在内部运动的路程长短就好，路程出来，时间自然也就出来了。</p>

<p>第4种，根据对称我们知道，弹射之后的小球在圆环内部运动的路程与之前运动的路程相等，所以只需要求出之前运动的路程，然后乘2就能得出结果。</p>

<p>我简单说一下具体怎么求路程，先看下图<img src="http://hoowater.github.io/picture/hdu4793/C3.png" alt="" /></p>

<p>d1 = R+r, 我们求路程s，只需要求出圆心到直线距离d，然后根据勾股定理即可算出。而d的求法呢，也很简单，一种是根据点与直线的距离公式，利用解析几何的知识来求（这个不知道的去翻高中课本）；另外一种是利用叉积，|a向量 × b向量| = 平行四边形面积，很容易求出d，进而求出s。</p>

<p>同理，对于第四种情况，只需要用类似的方法求出大圆和小圆对应的s的一半，然后相减就是在内部运动的距离的一半，这里不画图了，应该很简单就能理解把！</p>

<p>这道题其实还是特别简单的，甚至可以算是水题了，但是看榜上的队伍，好多都是在封榜之后过得这道题，为什么？实际上，这是一种对计算几何的恐惧症！或者说，大家都不太想去做计算几何这个东西，因为可能被卡精度啦什么的，最烦了！</p>

<p><a href="http://hoowater.github.io/acm/hdu/hdu4793/">参考代码</a></p>

<p>D Beavergnaw</p>

<p><a href="http://poj.org/problem?id=2405">POJ2405</a></p>

<p>这是一道十分简单的计算几何题目，就是按照这个图来说<img src="http://hoowater.github.io/picture/poj2405/1.jpg" alt="" /></p>

<p>给你空出来的那一部分的体积以及D，让你求d，就是简单地推导一番就好了，不要告诉我你不知道圆锥台体积公式，高中学的，即便不会的话应该也会圆锥体积公式吧？按照圆锥体积公式推一下也就能推出来了，我就不写推导的过程了，大家好好推一下，推导的时候细心的（我第一遍就推错了，o(╯□╰)o））</p>

<p>这个<a href="http://hoowater.github.io/acm/poj/poj2405/">参考代码</a>没什么价值，推出公式了之后，就是个a+b的问题。</p>

<p>E.Rotate</p>

<p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=4998">HDU4998</a></p>

<p>题意：把一个平面进行n次旋转，每次围绕着一个点o旋转rad弧度（o和rad都给出），旋转完之后，平面相对于原来相当于绕着某一个点旋转了一个弧度，目标是求这个点和弧度（[0&hellip;2*PI]）.</p>

<p>这道题，稍微有一点点难度，如果用计算几何模拟的方法的话，需要用到旋转和直线交点，这个实际上有板子也是很好敲的（敲的时候才发现，我竟然把这些东西忘得差不多了T_T,已经不能快速地默出板子了）。这里就说一下模拟的思路。</p>

<p>首先随意选取两个点p1,q1（离得不要太近，否则可能出现精度问题），然后按照他给的步骤进行旋转，旋转完后得到2各点p2,q2，然后求线段p1p2 和 线段q1q2 中垂线的交点s，就是那个圆心。然后看向量sp2 与 向量sp1(sq2 和 sq1 也行)之间的角度差是多少即可。</p>

<p>有关这部分的模板，可以自行百度或者看书，这里提供我整理的一部分点线相关的模板，有兴趣的可以<a href="http://hnnwang.github.io/blog/2014/08/17/ping-mian-ji-suan-ji-he-dian-yu-xian-xiang-guan-zong-jie/">去看看</a>,还是那句话，不着急，这些以后都会讲。</p>

<p>这里我说一点,求极角的atan2(y, x)函数，他所求的极角的范围是（-PI，PI）</p>

<p>我的<a href="http://hoowater.github.io/acm/hdu/hdu4998/">参考代码</a>在这里,一样，最好自己做出来！</p>

<p>峰霸还有有其他的解法：</p>

<p>F.Connect Line Segment</p>

<p><a href="http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2117">AOJ2117</a></p>

<p>这道题是一个防AK的题目，反正如果我之前没有做过这题让我来打这场比赛，估计是没有时间把这道题写出来了。有一定基础的人再看这个题解吧！</p>

<p>题意：给你n条线段（2 &lt;= n &lt;= 14），每条线段用2个点来表示，然后让你把这些线段首尾相连练成一条折线，问折线最短有多长。</p>

<p>这道题，我们发现n的范围，很小，只有14，能想到什么？或许会有人说，暴力！可是你想一下，暴力的话，相当于求这几条线段的全排列，14！ = 87178291200，况且每条线段有2端，还需*2，显然，这是不可能在8s内完成的（实际上，AOJ上基本所有题目要求都是8s）。那么还能想到什么呢？如果知道状态压缩dp的人可能会想到状态压缩dp，没错，这题就是用状态压缩dp解决的（至少我是这么解决的）。这个题解如果不懂什么事状态压缩dp的就不要看了，以后讲了可以拿这个来练练手。</p>

<p>设dp[i][state][p]来代表在state状态下，当前线段的最后一条线段为i，且对应的外部的端点为p所代表的端点的情况下，连接所用的线段的最短长度。</p>

<p>可能上面的叙述不太好理解，我来解释一下，state代表的是当前有那些线段被用了，二进制1代表用了，0代表没有被用。p有2各取值，分别对应线段的2各端点，然后就状态转移方程</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="n">dp</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">state</span><span class="o">|</span><span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">j</span><span class="p">)][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">dp</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">state</span><span class="o">|</span><span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">j</span><span class="p">)][</span><span class="mi">0</span><span class="p">],</span><span class="n">min</span><span class="p">(</span><span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">state</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="p">(</span><span class="n">seg</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">a</span><span class="o">-</span><span class="n">seg</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">b</span><span class="p">).</span><span class="n">length</span><span class="p">(),</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">state</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">seg</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">b</span> <span class="o">-</span> <span class="n">seg</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">b</span><span class="p">).</span><span class="n">length</span><span class="p">()));</span>
</span><span class='line'>
</span><span class='line'><span class="n">dp</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">state</span><span class="o">|</span><span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">j</span><span class="p">)][</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">dp</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">state</span><span class="o">|</span><span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">j</span><span class="p">)][</span><span class="mi">1</span><span class="p">],</span><span class="n">min</span><span class="p">(</span><span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">state</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="p">(</span><span class="n">seg</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">a</span><span class="o">-</span><span class="n">seg</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">a</span><span class="p">).</span><span class="n">length</span><span class="p">(),</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">state</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">seg</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">b</span> <span class="o">-</span> <span class="n">seg</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">a</span><span class="p">).</span><span class="n">length</span><span class="p">()));</span>
</span></code></pre></td></tr></table></div></figure>


<p>就可以得出结果了，具体的大家可以去看我的<a href="http://hoowater.github.io/acm/aoj/aizu2117/">参考代码</a></p>

<p>最后，我再说一下这次出题的目的，其实本来我出的比这个稍微简单一些的，但是应某人要求，就去掉了一道签到题，加了一个Rotate，不过这个不是重点。看看题解，其实你会发现，如果你稍微对计算几何了解一些的话，这些题都是很简单的。A题，敢于暴力一下的话，就是个水的不能再水的凸包；C题，就是一个简单的公式推导，只要你高中数学解析几何不要太差就好；D题，就是一个体积的加减，细心点就很快就能出来；E题，想想如果你知道旋转怎么写，知道一些高中解析几何的知识，然后了解atan2这个函数，那么这题也就是一道简单的模拟（旋转什么的，都是有模板的）。F题是一个披着计算几何外壳的状态压缩dp，这个题是有点难度的！</p>

<p>好了，这里直接点出我的目的：提醒你们一下，不要忽视了计算几何，以后组了队之后，一个队伍至少要找出一个人来，搞上那么一段时间的计算几何（不用太久，1星期就差不多了！），然后这种简单的题目做起来就没什么难度了！为什么要这样说呢，因为经过几场多校训练和网络赛我发现，计算几何的题目，很多的水平不是很高的队伍都没有好好地搞一搞，如果我们对计算几何这方面稍微用点心的话（实际上，不用付出太多），那么，如果遇到计算几何的题目，对比其他队伍就很是沾光！我们的队伍在多校训练以及网络赛的时候，但凡是碰到有计算几何的场次，一般都会打得比较好，因为我弄了一段时间的计算几何！举几个例子，鞍山赛区网络赛，也就是你们做的这个Rotate的题目（E题），我们的队伍用了很短的时间1A，而有另外一个学长队伍13A，过得还很晚；再举个例子，北京区域赛，你们另外一个学长队伍，由于没有搞过计算几何，所以栽在了一个题目上，不是没有做出来，而是WA得太多，结果很遗憾地与铜奖失之交臂！（这道题目其实也很简单，反正我在下面做是1A的）。</p>

<p>现在说这些其实还是有点早，不过就当是提个醒吧，要注意，我说的不是计算几何多么多么重要，而是提醒你们以后不要忽视计算几何，不过也不用着急，其实如果为了成绩的话，一个队伍有一个人搞得比较不错就行！</p>

<p>大家以后继续加油！</p>

<p><a href="http://hoowater.github.io/blog/archives">返回</a></p>
]]></content>
  </entry>
  
</feed>
